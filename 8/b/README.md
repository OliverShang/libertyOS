# 内存管理
## 一、物理内存管理 & 页表的建立
### 1. Loader
- `DispMemInfo`打印物理内存信息的同时，记录`ADRS.Type = 1 (AddressRangeMemory)`的内存块的`Base`和`Length`，并确定存放页表的物理基地址;
- 按需建立页表，使用对等映射（线性地址 = 物理地址）但保留存放映射 4G 地址空间的页表所需的内存，详见`SetupPaging`;
- `SaveMemInfo`将`DispMemInfo`记录的物理内存信息保存到虚拟地址`0x8000`，后续由内存管理模块`MM`获取.

### 2. 内存管理模块`MM`的初始化操作`init_mm()`
获取`Loader`保存在虚拟地址`0x8000`的内存信息，并完成内存管理信息的初始化：
- `MM`管理的物理内存是存放页表的那一块;
- 存放二级页表最多需要 4MB + 1KB 内存，这部分内存被保留，紧随其后建立双向循环链表`pf_list`，以页为单位记录内存块的信息：
	- 页框的引用计数——该页框被多少个`PTE`映射
	- 页框的类型:
		- `PAGE_FREE`(空闲的页框，可被分配出去)
		- `PAGE_RESERVED`(被保留的页框，包括存放页表和双向循环链表`pf_list`所占据的页框)
		- `PAGE_MAPPED`(页框已被页表映射)
	- 页框的保护属性——只读、可读写
- 清理页表，将`PAGE_FREE`类型的页框从页表中解除映射, 需要的时候再建立映射.

## 二、虚拟内存分配
虚拟内存分配由`MM`模块的`do_vm_alloc()`完成，对外提供接口`vm_alloc`.

### **`do_vm_alloc()`的要点：**
- 通过双向循环链表`pf_list`找到可供分配的页框. 由于`pf_list`记录的页框地址是连续、递增的，且分配的起点是第一个`PAGE_FREE`的页框，这意味着被分配出去的页框都是连续的，不存在以页为单位的物理内存碎块；
- 分配出去的虚页及其所对应的页框都是连续的.

## 三、系统的内存布局
目前的内存布局图：

![内存布局图](screenshot/mem.png)

**页表所实现的地址映射：**
> 使用 Bochs 测试，存放二级页表的物理基地址是`100000H`

| 页表编号 | 页表的物理基地址 | 页表映射的线性地址范围 |
|--------|--------|--------|
| 0 | 101000H | 0 ~ 4M |
| 1 | 102000H | 4M ~ 8M |
| 2 | 103000H | 8M ~ 12M |
| 3 | 104000H | 12M ~ 16M |
| ... | ... | ... |

## 四、测试
测试代码在`kernel/main.c`的`TaskC`里面.

### 结果分析：
#### 1. 分配虚拟内存`11M ~ 13M`
- 线性地址`11M = B00000H`, PDE索引=`2`, PTE索引=`300H`. 所以第一个PTE的物理地址是`103000H + 300H * 4 = 103C000H`, 该PTE对应的页框地址是`530000H`；往后需要填写的PTE个数=`2M / 4K = 512`, 跨越1号和2号页表. 本次分配将线性地址`11M ~ 13M`映射到物理地址`530000H ~ 730000H`, 页表的首尾如下图所示:

![](screenshot/pte-1-1.png)

![](screenshot/pte-1-2.png)

使用线性地址和物理地址查看内存：

![](screenshot/mem-1.png)

#### 2. 分配虚拟内存`8M ~ 12M`
此次的线性地址范围与上一次有重叠，分配失败.

#### 3. `28M ~ 28M + 7K` 成功; `9M ~ 12M` 失败

## 五、`vm_alloc`的应用——`fork()`
`fork()`为进程分配内存时调用`vm_alloc`

## 六、尾声
此次扩展`MM`模块时发现了进程通信模块的BUG，主要包括`unblock`、`sys_sendrecv`和`msg_send`；另外修改了几个函数接口.
